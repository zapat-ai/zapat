{{TASK_ASSESSMENT}}

## Issue Details
- **Repository**: {{REPO}}
- **Issue #{{ISSUE_NUMBER}}**: {{ISSUE_TITLE}}
- **Labels**: {{ISSUE_LABELS}}
- **Complexity**: {{COMPLEXITY}}

**Issue Description:**
{{ISSUE_BODY}}

{{MENTION_CONTEXT}}

## Project Context
{{PROJECT_CONTEXT}}

## Workflow

{{#IF_CLAUDE}}
If you are spawning a team, your **FIRST action** must be to call the `TeamCreate` tool, then use the `Task` tool to spawn each teammate. If working solo (only for `solo` complexity), skip team creation steps.

1. **Phase 1 — Planning** (if team: all participate; if solo: plan yourself):
   - Read relevant source files to understand existing patterns. Propose implementation plan.
   - If team: Product manager confirms scope — not too broad, not too narrow. All share input before building starts.

   **Interface Contract Check:** If the issue body contains an `## Interface Contract` section, the builder MUST implement exactly that interface — same method names, parameter types, return types, and delegate/callback signatures. Do NOT deviate from the contract. Other agents are implementing against the same contract in parallel.

   **Backend API Spec Check:** If the issue body contains a `## Backend API Spec` section, the builder MUST use exactly that API — same HTTP method, URL, headers, and body format. Do NOT infer the backend API from other existing code. Existing code may use a different pattern (e.g., presigned S3 URLs vs. direct POST). Only the spec in the issue body is authoritative.

   **Single Ownership Rule:** Only ONE agent should modify any given function. If this issue touches a function that another parallel issue also touches, coordinate via the interface contract. Do NOT add duplicate calls or redundant wiring — check what the contract specifies as your responsibility.

2. **Implementation** (builder works, others standby; if solo: implement yourself):
   - Implement changes following existing code conventions
   - Run any available tests/linters
   - Commit with conventional commit messages (feat:/fix:/refactor:)

3. **Tests** (builder, after implementation; if solo: write tests yourself):
   - Write unit tests for all new/changed functions and classes
   - Write integration tests if the change involves: API endpoints, database operations, or cross-service calls
   - If the repo has no test infrastructure yet:
     - Detect the stack (package.json → Jest/Vitest, .xcodeproj → XCTest)
     - Install test devDependencies
     - Create jest.config.js / vitest.config.ts / test target as needed
     - For .mjs files: configure Jest ESM with `NODE_OPTIONS=--experimental-vm-modules`
   - Run all tests — iterate until they pass
   - Mock external dependencies (AWS SDK, network calls, env vars) — never make real API calls
   - Use realistic but fictional test data
   - Commit tests with: `test: add tests for [description]`
   - If you notice untested existing code unrelated to this PR, create a GitHub issue:
     ```
     gh issue create --repo {{REPO}} --title "Write tests for [area]" --body "..." --label "agent-write-tests"
     ```

4. **Review** (skip if working solo):
   - If you spawned a security reviewer: Check for hardcoded secrets, insecure storage, missing auth, OWASP vulnerabilities.
   - If you spawned a UX reviewer: Check for UI friction, accessibility, consistency with existing UX patterns.
   - If you spawned a product manager: Verify the implementation meets all acceptance criteria from the issue.
   - All reviewers: Verify tests exist for new/changed code. Flag missing tests as [BLOCKING].
   - All send feedback to builder via messages.

5. **Iterate & Ship**:
   - If team: Builder addresses all feedback. After all reviewers approve, push and create PR.
   - If solo: Complete the mandatory security checklist from the task assessment before pushing. Check all callers of any modified function in unmodified files. Then push and create PR.
   ```
   git push origin HEAD
   gh pr create --title "feat: [description]" --body "..." --label "zapat-review"
   ```
   Link the issue in the PR body with "Closes #{{ISSUE_NUMBER}}".
   The `zapat-review` label triggers the automated PR review agent on the next poll cycle.

   **Target Branch:** If the issue body contains a `**Target Branch:** feature/SLUG` directive, the PR MUST target that branch instead of the default branch. Use:
   ```
   gh pr create --title "feat: [description]" --body "..." --label "zapat-review" --base feature/SLUG
   ```

6. **Shut down the team** when done (skip if working solo).
{{/IF_CLAUDE}}
{{#IF_CODEX}}
You are working solo. Complete all phases sequentially.

1. **Phase 1 — Planning**:
   - Read relevant source files to understand existing patterns. Propose implementation plan.

   **Interface Contract Check:** If the issue body contains an `## Interface Contract` section, you MUST implement exactly that interface — same method names, parameter types, return types, and delegate/callback signatures. Do NOT deviate from the contract.

   **Backend API Spec Check:** If the issue body contains a `## Backend API Spec` section, you MUST use exactly that API — same HTTP method, URL, headers, and body format.

2. **Phase 2 — Implementation**:
   - Implement changes following existing code conventions
   - Run any available tests/linters
   - Commit with conventional commit messages (feat:/fix:/refactor:)

3. **Phase 3 — Tests**:
   - Write unit tests for all new/changed functions and classes
   - Write integration tests if the change involves: API endpoints, database operations, or cross-service calls
   - If the repo has no test infrastructure yet:
     - Detect the stack (package.json → Jest/Vitest, .xcodeproj → XCTest)
     - Install test devDependencies and create config as needed
   - Run all tests — iterate until they pass
   - Mock external dependencies — never make real API calls
   - Commit tests with: `test: add tests for [description]`

4. **Phase 4 — Self-Review**:
   Perform a rigorous review from multiple perspectives:
   - **Security**: No hardcoded secrets, no injection risks, auth checks present, all callers of modified functions verified
   - **Code quality**: Follows existing patterns, no regressions, proper error handling
   - **Product**: Meets all acceptance criteria from the issue

5. **Phase 5 — Ship**:
   Push and create PR:
   ```
   git push origin HEAD
   gh pr create --title "feat: [description]" --body "..." --label "zapat-review"
   ```
   Link the issue in the PR body with "Closes #{{ISSUE_NUMBER}}".

   **Target Branch:** If the issue body contains a `**Target Branch:** feature/SLUG` directive, the PR MUST target that branch instead of the default branch.
{{/IF_CODEX}}

### Safety Notes
- NEVER modify files outside the working directory
- Keep changes minimal and focused on the issue
