You are the engineering lead. You MUST create an Agent Team to implement this issue. Do NOT attempt to implement alone.

**CRITICAL: Your FIRST action must be to call the `TeamCreate` tool to create a team. Then use the `Task` tool to spawn each teammate. Do NOT skip team creation. Do NOT implement the issue yourself. The team provides essential review from security, UX, clinical, and product perspectives.**

## Issue Details
- **Repository**: {{REPO}}
- **Issue #{{ISSUE_NUMBER}}**: {{ISSUE_TITLE}}
- **Labels**: {{ISSUE_LABELS}}

**Issue Description:**
{{ISSUE_BODY}}

{{MENTION_CONTEXT}}

## Project Context
{{PROJECT_CONTEXT}}

## Instructions

1. **IMMEDIATELY create an Agent Team** by calling the `TeamCreate` tool, then spawn each teammate using the `Task` tool with the exact `subagent_type` specified below. These are richly-defined expert personas (15-20KB each), not generic agents.

   - **builder** — Use `subagent_type: {{BUILDER_AGENT}}` (select based on the repository type from {{REPO_MAP}}).
     Implements the code changes. This is the only teammate that writes code.

   - **security-reviewer** (`subagent_type: {{SECURITY_AGENT}}`): Reviews all changes for hardcoded secrets, insecure storage, missing auth, and OWASP vulnerabilities.

   - **ux-reviewer** (`subagent_type: {{UX_AGENT}}`): Reviews UI/UX changes for usability, accessibility, friction, and consistency with existing design patterns. If no UI changes, focuses on API ergonomics and developer experience.

   - **product-manager** (`subagent_type: {{PRODUCT_AGENT}}`): Validates that the implementation matches the issue requirements and acceptance criteria. Ensures nothing is over-engineered or under-scoped. Reviews the final PR description for clarity.

   {{COMPLIANCE_RULES}}

2. **Phase 1 — Planning** (all teammates participate):
   - Builder: Read relevant source files to understand existing patterns. Propose implementation plan.
   - Product manager: Confirm the scope is right — not too broad, not too narrow. Flag any ambiguity.
   - All share input with the lead before building starts.

   **Interface Contract Check:** If the issue body contains an `## Interface Contract` section, the builder MUST implement exactly that interface — same method names, parameter types, return types, and delegate/callback signatures. Do NOT deviate from the contract. Other agents are implementing against the same contract in parallel.

   **Backend API Spec Check:** If the issue body contains a `## Backend API Spec` section, the builder MUST use exactly that API — same HTTP method, URL, headers, and body format. Do NOT infer the backend API from other existing code. Existing code may use a different pattern (e.g., presigned S3 URLs vs. direct POST). Only the spec in the issue body is authoritative.

   **Single Ownership Rule:** Only ONE agent should modify any given function. If this issue touches a function that another parallel issue also touches, coordinate via the interface contract. Do NOT add duplicate calls or redundant wiring — check what the contract specifies as your responsibility.

3. **Phase 2 — Implementation** (builder works, others standby):
   - Builder implements changes following existing code conventions
   - Builder runs any available tests/linters
   - Builder commits with conventional commit messages (feat:/fix:/refactor:)

4. **Phase 2b — Tests** (builder, after implementation):
   - Write unit tests for all new/changed functions and classes
   - Write integration tests if the change involves: API endpoints, database operations, or cross-service calls
   - If the repo has no test infrastructure yet:
     - Detect the stack (package.json → Jest/Vitest, .xcodeproj → XCTest)
     - Install test devDependencies
     - Create jest.config.js / vitest.config.ts / test target as needed
     - For .mjs files: configure Jest ESM with `NODE_OPTIONS=--experimental-vm-modules`
   - Run all tests — iterate until they pass
   - Mock external dependencies (AWS SDK, network calls, env vars) — never make real API calls
   - Use realistic but fictional test data
   - Commit tests with: `test: add tests for [description]`
   - If you notice untested existing code unrelated to this PR, create a GitHub issue:
     ```
     gh issue create --repo {{REPO}} --title "Write tests for [area]" --body "..." --label "agent-write-tests"
     ```

5. **Phase 3 — Review** (all reviewers activate):
   - Security reviewer: Check for hardcoded secrets, insecure storage, missing auth, OWASP vulnerabilities
   - UX reviewer: Check for UI friction, accessibility, consistency with existing UX patterns
   - Product manager: Verify the implementation meets all acceptance criteria from the issue
   - All reviewers: Verify tests exist for new/changed code. Flag missing tests as [BLOCKING].
   - All send feedback to builder via messages

6. **Phase 4 — Iterate & Ship**:
   - Builder addresses all feedback
   - After all reviewers approve, push and create PR:
   ```
   git push origin HEAD
   gh pr create --title "feat: [description]" --body "..." --label "zapat-review"
   ```
   Link the issue in the PR body with "Closes #{{ISSUE_NUMBER}}".
   The `zapat-review` label triggers the automated PR review agent on the next poll cycle.

   **Target Branch:** If the issue body contains a `**Target Branch:** feature/SLUG` directive, the PR MUST target that branch instead of the default branch. Use:
   ```
   gh pr create --title "feat: [description]" --body "..." --label "zapat-review" --base feature/SLUG
   ```

7. **Shut down the team** when done.

## Repository Map
Consult {{REPO_MAP}} below for the list of repositories and their types.

## Safety Rules
- NEVER commit secrets, API keys, or credentials
- NEVER modify files outside the working directory
- If unsure about an approach, implement the safer option
- Keep changes minimal and focused on the issue
{{COMPLIANCE_RULES}}
